package repository

import (
	"log"
	"os"

	"github.com/4yrg/gradeloop-core-v2/apps/services/iam-service/internal/domain"
	"github.com/4yrg/gradeloop-core-v2/apps/services/iam-service/internal/utils"
	"gorm.io/gorm"
)

func Seed(db *gorm.DB) error {
	log.Println("Seeding database...")

	// 1. Seed Permissions
	permissions := []string{
		domain.PermissionUserCreate,
		domain.PermissionUserRead,
		domain.PermissionUserUpdate,
		domain.PermissionUserDelete,
		domain.PermissionRoleCreate,
		domain.PermissionRoleRead,
		domain.PermissionRoleUpdate,
		domain.PermissionRoleDelete,
		domain.PermissionRoleAssign,
		domain.PermissionAuditRead,
	}

	permMap := make(map[string]domain.Permission)

	for _, permName := range permissions {
		var perm domain.Permission
		if err := db.Where("name = ?", permName).First(&perm).Error; err != nil {
			if err == gorm.ErrRecordNotFound {
				perm = domain.Permission{Name: permName, Description: "System Permission"}
				if err := db.Create(&perm).Error; err != nil {
					return err
				}
				log.Printf("Created Permission: %s", permName)
			} else {
				return err
			}
		}
		permMap[permName] = perm
	}

	// 2. Seed Roles and Assign Permissions
	roles := map[string][]string{
		domain.RoleSuperAdmin: permissions, // Super Admin gets all permissions
		domain.RoleAdmin: {
			domain.PermissionUserCreate,
			domain.PermissionUserRead,
			domain.PermissionUserUpdate,
			domain.PermissionRoleRead,
			domain.PermissionRoleAssign,
			domain.PermissionAuditRead,
		},
		domain.RoleInstructor: {
			domain.PermissionUserRead,
		},
		domain.RoleStudent: {
			// Students might have limited read permissions or specific ones
		},
	}

	for roleName, rolePerms := range roles {
		var role domain.Role
		if err := db.Where("name = ?", roleName).First(&role).Error; err != nil {
			if err == gorm.ErrRecordNotFound {
				role = domain.Role{Name: roleName, Description: "System Role"}
				if err := db.Create(&role).Error; err != nil {
					return err
				}
				log.Printf("Created Role: %s", roleName)
			} else {
				return err
			}
		}

		// Assign Permissions to Role
		var permsToAssign []domain.Permission
		for _, pName := range rolePerms {
			if p, ok := permMap[pName]; ok {
				permsToAssign = append(permsToAssign, p)
			}
		}

		if len(permsToAssign) > 0 {
			if err := db.Model(&role).Association("Permissions").Replace(permsToAssign); err != nil {
				return err
			}
		}
	}

	// 3. Seed Super Admin User
	superAdminEmail := os.Getenv("SUPER_ADMIN_EMAIL")
	if superAdminEmail == "" {
		superAdminEmail = "superadmin@gradeloop.com"
	}
	superAdminPass := os.Getenv("SUPER_ADMIN_PASSWORD")
	if superAdminPass == "" {
		superAdminPass = "superadmin"
	}

	var superAdmin domain.User
	if err := db.Where("email = ?", superAdminEmail).First(&superAdmin).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			// Create Super Admin
			hashedPassword, _ := utils.HashPassword(superAdminPass)

			superAdmin = domain.User{
				Email:        superAdminEmail,
				FullName:     "Super Admin",
				PasswordHash: hashedPassword,
				UserType:     domain.UserTypeEmployee,
				IsActive:     true,
				// Create dummy employee details for validation if strict
				EmployeeID:   &[]string{"SYSADMIN"}[0],
				Designation:  &[]string{"System Administrator"}[0],
				EmployeeType: &[]string{"Permanent"}[0],
			}
			if err := db.Create(&superAdmin).Error; err != nil {
				return err
			}
			log.Printf("Created Super Admin: %s", superAdminEmail)

			// Assign Super Admin Role
			var saRole domain.Role
			if err := db.Where("name = ?", domain.RoleSuperAdmin).First(&saRole).Error; err == nil {
				if err := db.Model(&superAdmin).Association("Roles").Append(&saRole); err != nil {
					return err
				}
			}
		} else {
			return err
		}
	}

	log.Println("Seeding completed.")
	return nil
}
