# GradeLoop Core V2 - Web Client Context

This project is a high-performance web client built with **Bun**, **Next.js (App Router)**, and a strictly typed ecosystem for an AI-integrated Learning Management System (LMS).

---

# Primary Tech Stack

- **Runtime**: Bun (Strictly use `bun` for scripts and package management)
- **Framework**: Next.js 16+ (App Router)
- **UI Architecture**: shadcn/ui (Radix UI + TailwindCSS v4)
- **Animation**: Motion (`motion` package only — never `framer-motion`)
- **State Management**: Zustand v5 (Store-based, immutable state)
- **Data Layer**: TanStack Query v5
- **HTTP Client**: Axios (Instance-based)
- **Form Handling**: React Hook Form v7 with Hookform Resolvers
- **Validation**: Zod v4 (Schema-first development)
- **Styling**: TailwindCSS v4 with PostCSS
- **Utilities**: clsx (or `cn` utility), date-fns
- **Icons**: lucide-react

---

# Development Standards & Patterns

(keep the same expectations as before for the web client; see sections below for specific rules)

---

# Go Backend — auth-service (new / updated guidance)

This repo contains a Go-based authentication service at `apps/services/auth-service`. The LLM/context file needs to include the folder structure and notes so AI agents and contributors understand the service layout, conventions, and environment variables.

Auth-service folder structure (top-level)
```
apps/services/auth-service/
├── cmd/               # entrypoints (e.g., cmd/main.go)
├── config/            # env loader, configuration helpers
├── database/          # DB connection and migrations
├── handler/           # HTTP handlers
├── middleware/        # middleware (auth, logging, etc.)
├── model/             # domain models and GORM models
├── router/            # routes setup (fiber or similar)
├── tmp/                # ephemeral files (ignored)
├── Dockerfile
├── README.md
├── go.mod
└── go.sum
```

Directory responsibilities and notes
- `cmd/`:
  - Holds `main` packages for running the service.
  - Typical command to run locally: `go run ./cmd/main.go` (or use `air` for hot reload if configured).
- `config/`:
  - Centralized env loader using `github.com/joho/godotenv` (the service ships logic that searches parent directories for `.env`).
  - Use `config.Config("KEY")` style helper across the service.
- `database/`:
  - DB connection logic (uses GORM + postgres driver).
  - Connection logic supports both:
    - Aiven-style connection via `POSTGRES_URL_BASE` + `AUTH_SVC_DB_NAME` (+ `POSTGRES_SSLMODE`)
    - Traditional env vars `DB_HOST`, `DB_PORT`, `DB_USER`, `DB_PASSWORD`, `DB_NAME`
  - For Aiven: set `POSTGRES_URL_BASE=postgres://user:pass@host:port/` and `AUTH_SVC_DB_NAME=<db>` and optionally `POSTGRES_SSLMODE=require`.
  - If `POSTGRES_URL_BASE` is present, the service will prefer that and append `AUTH_SVC_DB_NAME` as the path; otherwise it uses a formatted `host=... port=... user=...` DSN.
- `handler/`:
  - Route handlers (login/register, token endpoints).
  - Uses `config.Config("SECRET")` or similar for JWT signing.
- `middleware/`:
  - Authentication middleware (JWT validation), error handling helpers.
- `model/`:
  - GORM model definitions for `User`, `Role`, etc.
- `router/`:
  - Wiring of routes to handlers and middleware (e.g., Fiber app setup).
- `Dockerfile`:
  - Container recipe for building the service for local/dev or CI.
- `README.md`:
  - Service-specific docs and quickstart.

Environment variables (auth-service)
- Auth-specific:
  - `SECRET` — JWT secret (required)
  - `AUTH_SVC_DB_NAME` — DB name for the auth service when using Aiven-style URL (recommended if using Aiven)
- Aiven / remote DB:
  - `POSTGRES_URL_BASE` — base Postgres URL from Aiven (example: `postgres://avnadmin:xxx@<host>:<port>/`)
  - `POSTGRES_SSLMODE` — `require` for Aiven (optional)
  - When `POSTGRES_URL_BASE` and `AUTH_SVC_DB_NAME` are present, the service builds the full connection string using those values and includes `sslmode` when provided.
- Local DB fallback:
  - `DB_HOST`, `DB_PORT`, `DB_USER`, `DB_PASSWORD`, `DB_NAME` — used when `POSTGRES_URL_BASE` is not set.
- Compose & docker:
  - The infra compose can set `POSTGRES_URL_BASE` and `AUTH_SVC_DB_NAME` in the `.env` file. If you prefer local Postgres for dev, provide DB credentials instead.

Build & run (Go service)
- Local development:
  - `go install` / `go build` / `go run ./cmd/main.go`
  - Use `air` or similar for live reload (if included in Dockerfile / dev setup).
- Docker:
  - Build: `docker build -t gradeloop-auth-service .` (from `apps/services/auth-service`)
  - Run: `docker run --env-file ../../.env -p 3000:3000 gradeloop-auth-service`
- Compose (infra):
  - The minimal infra compose kept for auth-service expects external DB or Aiven. Ensure `.env` has the required Aiven vars before `docker compose up`.
- Testing:
  - Add unit tests using Go's `testing` package.
  - Use dependency injection for DB and external dependencies to enable testability.

Go tooling & code style
- Go version consistent with `go.mod` (respect `go 1.xx` in `go.mod`).
- Formatting: `gofmt -w .` and `goimports -w .`
- Linting: `golangci-lint run ./...` (recommended)
- Vet: `go vet ./...`
- Module management: `go mod tidy` to keep `go.mod` clean.

Security & secrets
- Do NOT hardcode secrets in source.
- Use `.env` (local dev) and environment configuration for production secrets (or secret management).
- Prefer Aiven's managed Postgres with secure SSL settings (e.g., `sslmode=require`).
- Ensure `SECRET` is strong, rotate periodically.

Observability & healthchecks
- The service exposes a simple health endpoint (root `/` or `/health` depending on implementation) — used by the compose healthcheck.
- Add structured logging (log level, JSON output for production) and request tracing fields (correlation id).
- Add Prometheus metrics if possible for production readiness.

---

# Java Backend (REMOVED)
- The Java backend section has been removed from this LLMs.txt. For this repository context, prioritize Go service documentation and configs and avoid instructing agents to rely on Java-specific tooling or JDK requirements.

---

# Project Structure Reference (web + selected services)

```
/apps/web/                # frontend (Next.js + Bun)
  ├── app/
  ├── components/
  ├── features/
  ├── lib/
  └── ...

/apps/services/           # microservices
  ├── auth-service/       # Go service (see structure above)
  ├── (other services...) # Java services removed from LLMs context unless present locally
```

---

# Critical Development Rules (summary)
- Strict TypeScript in the web client (no `any`).
- No raw API data without Zod parsing on the frontend.
- No NPM/Yarn for the web client: use Bun exclusively.
- For Go services:
  - Keep configuration in env files or external secret stores.
  - Do not hardcode DB credentials or secrets.
  - Use the Aiven-compatible connection flow when provided.

---

# Agent Instructions (for LLMs / automation)
- When asked to run or build services, verify the required directories exist in the repo before running `docker build` or `go build`.
- Prefer using prebuilt images for services not present locally (do not attempt to `build` when `context` path is missing).
- Use `POSTGRES_URL_BASE` + `AUTH_SVC_DB_NAME` for auth-service when available; fall back to `DB_*` env vars only when necessary.
- Do not instruct the agent to assume Java-based services are available unless their directories and build files exist.

---

# Quick reference commands

Frontend
- Install: `bun install`
- Dev: `bun run dev`
- Build: `bun run build`

Auth-service (Go)
- Build: `go build ./...` or `go build -o ./bin/auth ./cmd/main.go`
- Run: `go run ./cmd/main.go`
- Docker build: `docker build -t gradeloop-auth-service .` (from `apps/services/auth-service`)
- Lint & format: `gofmt -w . && goimports -w . && golangci-lint run ./...`

Docker Compose (infra/compose)
- From `infra/compose/`:
  - `docker compose up --build` (ensure build contexts exist or use images)
  - If using Aiven, populate `../../.env` with `POSTGRES_URL_BASE`, `AUTH_SVC_DB_NAME`, and `POSTGRES_SSLMODE=require` (and leave local DB vars empty).

---

If you need additional detail for any other service folder structures or want the Go auth-service README expanded with exact commands and examples, let me know and I will add the expanded how-to and examples (DB migration commands, sample `.env`, sample requests, etc.).


Traefik API Gateway Implementation Guide (v3.0)
----------------------------------------------
This section contains a ready-to-copy Docker Compose example (modular, commented), Traefik label examples for the existing `auth-service`, a reusable "Future Service Template" (commented-out labels you can copy/paste for new services), and verification steps using `curl`. The provided compose and traefik examples are intentionally self-contained for local/dev use and assume Traefik v3.0.

Important notes (w.r.t. the repo)
- The `auth-service` in this repo lives at `apps/services/auth-service` and listens internally on port `3000`. The compose/labels below keep that service unreachable from the host (no published ports) so Traefik is the only entrypoint.
- The Traefik provider uses the Docker socket for service discovery. The Docker provider is configured with `exposedByDefault=false` so only services with explicit `traefik.enable=true` labels become routable.
- Network: a dedicated Docker network `gateway_network` is used so Traefik and services discover each other safely.

Example compose.yaml
- Place this file where you keep infra manifests (e.g., `infra/compose/docker-compose.yaml`). It is presented here as an example you can copy/paste.

```/dev/null/compose.yaml#L1-260
version: "3.8"

services:
  traefik:
    image: traefik:v3.0
    command:
      # Static configuration for Traefik (entrypoints, providers, dashboard)
      - --entryPoints.web.address=:80                      # public HTTP
      - --entryPoints.traefik.address=:8080               # Traefik dashboard
      - --providers.docker=true                           # enable Docker provider
      - --providers.docker.exposedbydefault=false         # only explicit services are exposed
      - --api.dashboard=true                              # enable dashboard
      - --log.level=INFO
    ports:
      - "80:80"       # web entrypoint
      - "8080:8080"   # traefik (dashboard) entrypoint
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro      # Docker socket for service discovery
    networks:
      - gateway_network
    # Keep Traefik container lightweight; use labels if you want to secure the dashboard with auth.

  auth-service:
    image: my-registry/auth-service:latest                # placeholder image (replace with your registry)
    environment:
      - PORT=3000
      # add other ENV variables the service needs (SECRET, DB connection, etc.)
    expose:
      - "3000"                                             # internal port only — no host port mapping
    labels:
      # Enable Traefik for this container
      - "traefik.enable=true"

      # Router: map requests with PathPrefix /api/auth to this service
      - "traefik.http.routers.auth.rule=PathPrefix(`/api/auth`)"
      - "traefik.http.routers.auth.entrypoints=web"

      # Attach middlewares (strip prefix so internal service sees /login instead of /api/auth/login,
      # and rateLimit to limit requests to protect against brute-force)
      - "traefik.http.routers.auth.middlewares=auth-stripprefix@docker,auth-ratelimit@docker"

      # Middleware: strip the /api/auth prefix before forwarding to the service
      - "traefik.http.middlewares.auth-stripprefix.stripPrefix.prefixes=/api/auth"

      # Middleware: rate limiting (average = allowed reqs per second, burst = allowed burst)
      - "traefik.http.middlewares.auth-ratelimit.rateLimit.average=10"
      - "traefik.http.middlewares.auth-ratelimit.rateLimit.burst=20"

      # Service: tell Traefik to forward to internal port 3000
      - "traefik.http.services.auth.loadbalancer.server.port=3000"

      # Optional: add a healthcheck path to the router (if your service exposes /health)
      # - "traefik.http.routers.auth.rule=PathPrefix(`/api/auth`) && PathPrefix(`/health`)"

      # Inline comments above explain purpose of each label. Remove comments if copying labels elsewhere.
    networks:
      - gateway_network
    # NOTE: Do NOT publish ports here — the service must be reachable only via Traefik for this architecture.

networks:
  gateway_network:
    name: gateway_network
    driver: bridge
```

Traefik static/dynamic config notes
- The compose above uses command-line args for the minimum static configuration (entrypoints, docker provider).
- The dashboard is enabled via `--api.dashboard=true`. For production you should secure the dashboard (auth, IP allowlist, or remove dashboard exposure).
- We use the Docker provider + socket so Traefik discovers services and their labels automatically.
- `exposedByDefault=false` prevents accidental exposure of containers; only containers explicitly labeled with `traefik.enable=true` will be routed.

Labels explained (short)
- `traefik.enable=true`: expose container to Traefik.
- `traefik.http.routers.<name>.rule`: routing rule (PathPrefix/Host/Path).
- `traefik.http.routers.<name>.entrypoints`: which entrypoint(s) the router listens on (`web`/`traefik`).
- `traefik.http.routers.<name>.middlewares`: comma-separated middleware list.
- `traefik.http.middlewares.<name>.stripPrefix.prefixes`: prefixes to strip from the request path.
- `traefik.http.middlewares.<name>.rateLimit.average` and `.burst`: rate limiting settings.
- `traefik.http.services.<name>.loadbalancer.server.port`: internal container port to forward traffic to.

Future Service Template (copy-paste)
- Use this commented block when you add more microservices. Copy the labels and adjust service name, internal port, and path.

```/dev/null/future-service-template.txt#L1-120
# ---------------------------
# Future service labels template
# ---------------------------
# - Replace <svc> with your service name (e.g., "users")
# - Replace /api/<svc> with the route you'd like exposed
#
# Example labels to add under the service in docker-compose:
#
# - "traefik.enable=true"
# - "traefik.http.routers.<svc>.rule=PathPrefix(`/api/<svc>`)"
# - "traefik.http.routers.<svc>.entrypoints=web"
# - "traefik.http.routers.<svc>.middlewares=<svc>-stripprefix@docker,<svc>-ratelimit@docker"
# - "traefik.http.middlewares.<svc>-stripprefix.stripPrefix.prefixes=/api/<svc>"
# - "traefik.http.middlewares.<svc>-ratelimit.rateLimit.average=10"
# - "traefik.http.middlewares.<svc>-ratelimit.rateLimit.burst=20"
# - "traefik.http.services.<svc>.loadbalancer.server.port=<INTERNAL_PORT>"
#
# Adjust rateLimit values to suit the endpoint (e.g., lower for auth endpoints).
```

Verifying routing with curl
- Basic health check (GET):
  - curl -i http://localhost/api/auth/health
    - This should reach your auth-service `/health` endpoint (since the `/api/auth` prefix is stripped).
- Login example (POST JSON):
  - curl -i -X POST http://localhost/api/auth/login \
      -H "Content-Type: application/json" \
      -d '{"username":"alice","password":"secret"}'
    - Traefik will forward the request to the auth service as `/login`.
- Inspect headers / debug:
  - curl -i -H "Host: localhost" http://localhost/api/auth/...
  - Use `-v` for verbose output and to confirm the connection.
- Verify rate limiting:
  - Use a simple loop to send >10 requests/second and observe HTTP 429 responses when the rate limit is exceeded:
    - for i in $(seq 1 50); do curl -s -o /dev/null -w "%{http_code}\n" http://localhost/api/auth/health & done
    - Look for 429's among the results (behavior depends on burst settings and service response times).

Traefik Dashboard
- Dashboard (for dev): http://localhost:8080/dashboard/
  - Use with caution on public networks. In production secure it (basic auth, IP whitelist, or remove the port mapping).

Security & production notes
- In production:
  - Do not enable the dashboard as "insecure/unprotected".
  - Use TLS (define `entryPoints.web.http.tls=true` / configure certresolver).
  - Use stricter rate limits for auth endpoints and add other security middlewares (IP allowlist, auth middleware for management endpoints).
  - Consider running Traefik outside of Docker socket access or use socket with limited permissions and careful CI/CD practices.
- Secrets: pass service secrets (e.g., `SECRET`) via environment variables managed by your secret store or CI/CD — do not bake them in images.

How this avoids conflicts with the repo's `auth-service`
- The compose example uses `my-registry/auth-service:latest` as a placeholder. If you prefer building from local context, set the `build:` context to `./apps/services/auth-service` (but the instructions above were to use images for "plug-and-play" usage).
- The labels assume the service listens internally on `3000` — which matches the `auth-service` documented in this repo. Because we do NOT publish ports in compose, there is no port collision with the host or other services. Traefik routes to the container's internal port only.

Next steps / suggestions
- Copy the `compose.yaml` into `infra/compose/` or your chosen infra folder and run:
  - docker compose up -d
- Confirm `gateway_network` exists after startup. Compose will create it if not present.
- If you want me to add a real `infra/compose/docker-compose.yaml` file into this repository or a small CONTRIBUTING.md section describing how to run the gateway, I can add that as a follow-up change.

If you'd like, I can:
- Create the actual `infra/compose/docker-compose.yaml` file in the repo (with the Traefik and auth-service entries).
- Add a short "How to run the gateway" subsection to `CONTRIBUTING.md` and commit both files.
- Generate a minimal `traefik` static config file in `infra/traefik/` and wire it into compose.

Tell me which of those you'd like done next and I will prepare the files and edits.
